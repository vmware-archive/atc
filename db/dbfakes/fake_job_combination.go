// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"

	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
)

type FakeJobCombination struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	JobIDStub        func() int
	jobIDMutex       sync.RWMutex
	jobIDArgsForCall []struct{}
	jobIDReturns     struct {
		result1 int
	}
	jobIDReturnsOnCall map[int]struct {
		result1 int
	}
	CombinationStub        func() map[string]string
	combinationMutex       sync.RWMutex
	combinationArgsForCall []struct{}
	combinationReturns     struct {
		result1 map[string]string
	}
	combinationReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	BuildsStub        func(page db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		page db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	BuildStub        func(name string) (db.Build, bool, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		name string
	}
	buildReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	buildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	CreateBuildStub        func() (db.Build, error)
	createBuildMutex       sync.RWMutex
	createBuildArgsForCall []struct{}
	createBuildReturns     struct {
		result1 db.Build
		result2 error
	}
	createBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	EnsurePendingBuildExistsStub        func() error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct{}
	ensurePendingBuildExistsReturns     struct {
		result1 error
	}
	ensurePendingBuildExistsReturnsOnCall map[int]struct {
		result1 error
	}
	GetNextBuildInputsStub        func() ([]db.BuildInput, bool, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct{}
	getNextBuildInputsReturns     struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	getNextBuildInputsReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	GetIndependentBuildInputsStub        func() ([]db.BuildInput, error)
	getIndependentBuildInputsMutex       sync.RWMutex
	getIndependentBuildInputsArgsForCall []struct{}
	getIndependentBuildInputsReturns     struct {
		result1 []db.BuildInput
		result2 error
	}
	getIndependentBuildInputsReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 error
	}
	SaveNextInputMappingStub        func(inputMapping algorithm.InputMapping) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	saveNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	SaveIndependentInputMappingStub        func(inputMapping algorithm.InputMapping) error
	saveIndependentInputMappingMutex       sync.RWMutex
	saveIndependentInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
	}
	saveIndependentInputMappingReturns struct {
		result1 error
	}
	saveIndependentInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNextInputMappingStub        func() error
	deleteNextInputMappingMutex       sync.RWMutex
	deleteNextInputMappingArgsForCall []struct{}
	deleteNextInputMappingReturns     struct {
		result1 error
	}
	deleteNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJobCombination) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeJobCombination) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeJobCombination) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJobCombination) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJobCombination) JobID() int {
	fake.jobIDMutex.Lock()
	ret, specificReturn := fake.jobIDReturnsOnCall[len(fake.jobIDArgsForCall)]
	fake.jobIDArgsForCall = append(fake.jobIDArgsForCall, struct{}{})
	fake.recordInvocation("JobID", []interface{}{})
	fake.jobIDMutex.Unlock()
	if fake.JobIDStub != nil {
		return fake.JobIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.jobIDReturns.result1
}

func (fake *FakeJobCombination) JobIDCallCount() int {
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	return len(fake.jobIDArgsForCall)
}

func (fake *FakeJobCombination) JobIDReturns(result1 int) {
	fake.JobIDStub = nil
	fake.jobIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJobCombination) JobIDReturnsOnCall(i int, result1 int) {
	fake.JobIDStub = nil
	if fake.jobIDReturnsOnCall == nil {
		fake.jobIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.jobIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJobCombination) Combination() map[string]string {
	fake.combinationMutex.Lock()
	ret, specificReturn := fake.combinationReturnsOnCall[len(fake.combinationArgsForCall)]
	fake.combinationArgsForCall = append(fake.combinationArgsForCall, struct{}{})
	fake.recordInvocation("Combination", []interface{}{})
	fake.combinationMutex.Unlock()
	if fake.CombinationStub != nil {
		return fake.CombinationStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.combinationReturns.result1
}

func (fake *FakeJobCombination) CombinationCallCount() int {
	fake.combinationMutex.RLock()
	defer fake.combinationMutex.RUnlock()
	return len(fake.combinationArgsForCall)
}

func (fake *FakeJobCombination) CombinationReturns(result1 map[string]string) {
	fake.CombinationStub = nil
	fake.combinationReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeJobCombination) CombinationReturnsOnCall(i int, result1 map[string]string) {
	fake.CombinationStub = nil
	if fake.combinationReturnsOnCall == nil {
		fake.combinationReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.combinationReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *FakeJobCombination) Builds(page db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		page db.Page
	}{page})
	fake.recordInvocation("Builds", []interface{}{page})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildsReturns.result1, fake.buildsReturns.result2, fake.buildsReturns.result3
}

func (fake *FakeJobCombination) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeJobCombination) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return fake.buildsArgsForCall[i].page
}

func (fake *FakeJobCombination) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) Build(name string) (db.Build, bool, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Build", []interface{}{name})
	fake.buildMutex.Unlock()
	if fake.BuildStub != nil {
		return fake.BuildStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildReturns.result1, fake.buildReturns.result2, fake.buildReturns.result3
}

func (fake *FakeJobCombination) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeJobCombination) BuildArgsForCall(i int) string {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return fake.buildArgsForCall[i].name
}

func (fake *FakeJobCombination) BuildReturns(result1 db.Build, result2 bool, result3 error) {
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) BuildReturnsOnCall(i int, result1 db.Build, result2 bool, result3 error) {
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 bool
			result3 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) CreateBuild() (db.Build, error) {
	fake.createBuildMutex.Lock()
	ret, specificReturn := fake.createBuildReturnsOnCall[len(fake.createBuildArgsForCall)]
	fake.createBuildArgsForCall = append(fake.createBuildArgsForCall, struct{}{})
	fake.recordInvocation("CreateBuild", []interface{}{})
	fake.createBuildMutex.Unlock()
	if fake.CreateBuildStub != nil {
		return fake.CreateBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createBuildReturns.result1, fake.createBuildReturns.result2
}

func (fake *FakeJobCombination) CreateBuildCallCount() int {
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	return len(fake.createBuildArgsForCall)
}

func (fake *FakeJobCombination) CreateBuildReturns(result1 db.Build, result2 error) {
	fake.CreateBuildStub = nil
	fake.createBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJobCombination) CreateBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.CreateBuildStub = nil
	if fake.createBuildReturnsOnCall == nil {
		fake.createBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJobCombination) EnsurePendingBuildExists() error {
	fake.ensurePendingBuildExistsMutex.Lock()
	ret, specificReturn := fake.ensurePendingBuildExistsReturnsOnCall[len(fake.ensurePendingBuildExistsArgsForCall)]
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct{}{})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ensurePendingBuildExistsReturns.result1
}

func (fake *FakeJobCombination) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakeJobCombination) EnsurePendingBuildExistsReturns(result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) EnsurePendingBuildExistsReturnsOnCall(i int, result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	if fake.ensurePendingBuildExistsReturnsOnCall == nil {
		fake.ensurePendingBuildExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensurePendingBuildExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) GetNextBuildInputs() ([]db.BuildInput, bool, error) {
	fake.getNextBuildInputsMutex.Lock()
	ret, specificReturn := fake.getNextBuildInputsReturnsOnCall[len(fake.getNextBuildInputsArgsForCall)]
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct{}{})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNextBuildInputsReturns.result1, fake.getNextBuildInputsReturns.result2, fake.getNextBuildInputsReturns.result3
}

func (fake *FakeJobCombination) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakeJobCombination) GetNextBuildInputsReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) GetNextBuildInputsReturnsOnCall(i int, result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	if fake.getNextBuildInputsReturnsOnCall == nil {
		fake.getNextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.getNextBuildInputsReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJobCombination) GetIndependentBuildInputs() ([]db.BuildInput, error) {
	fake.getIndependentBuildInputsMutex.Lock()
	ret, specificReturn := fake.getIndependentBuildInputsReturnsOnCall[len(fake.getIndependentBuildInputsArgsForCall)]
	fake.getIndependentBuildInputsArgsForCall = append(fake.getIndependentBuildInputsArgsForCall, struct{}{})
	fake.recordInvocation("GetIndependentBuildInputs", []interface{}{})
	fake.getIndependentBuildInputsMutex.Unlock()
	if fake.GetIndependentBuildInputsStub != nil {
		return fake.GetIndependentBuildInputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getIndependentBuildInputsReturns.result1, fake.getIndependentBuildInputsReturns.result2
}

func (fake *FakeJobCombination) GetIndependentBuildInputsCallCount() int {
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	return len(fake.getIndependentBuildInputsArgsForCall)
}

func (fake *FakeJobCombination) GetIndependentBuildInputsReturns(result1 []db.BuildInput, result2 error) {
	fake.GetIndependentBuildInputsStub = nil
	fake.getIndependentBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJobCombination) GetIndependentBuildInputsReturnsOnCall(i int, result1 []db.BuildInput, result2 error) {
	fake.GetIndependentBuildInputsStub = nil
	if fake.getIndependentBuildInputsReturnsOnCall == nil {
		fake.getIndependentBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 error
		})
	}
	fake.getIndependentBuildInputsReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakeJobCombination) SaveNextInputMapping(inputMapping algorithm.InputMapping) error {
	fake.saveNextInputMappingMutex.Lock()
	ret, specificReturn := fake.saveNextInputMappingReturnsOnCall[len(fake.saveNextInputMappingArgsForCall)]
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
	}{inputMapping})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{inputMapping})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(inputMapping)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveNextInputMappingReturns.result1
}

func (fake *FakeJobCombination) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakeJobCombination) SaveNextInputMappingArgsForCall(i int) algorithm.InputMapping {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return fake.saveNextInputMappingArgsForCall[i].inputMapping
}

func (fake *FakeJobCombination) SaveNextInputMappingReturns(result1 error) {
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) SaveNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveNextInputMappingStub = nil
	if fake.saveNextInputMappingReturnsOnCall == nil {
		fake.saveNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) SaveIndependentInputMapping(inputMapping algorithm.InputMapping) error {
	fake.saveIndependentInputMappingMutex.Lock()
	ret, specificReturn := fake.saveIndependentInputMappingReturnsOnCall[len(fake.saveIndependentInputMappingArgsForCall)]
	fake.saveIndependentInputMappingArgsForCall = append(fake.saveIndependentInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
	}{inputMapping})
	fake.recordInvocation("SaveIndependentInputMapping", []interface{}{inputMapping})
	fake.saveIndependentInputMappingMutex.Unlock()
	if fake.SaveIndependentInputMappingStub != nil {
		return fake.SaveIndependentInputMappingStub(inputMapping)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveIndependentInputMappingReturns.result1
}

func (fake *FakeJobCombination) SaveIndependentInputMappingCallCount() int {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return len(fake.saveIndependentInputMappingArgsForCall)
}

func (fake *FakeJobCombination) SaveIndependentInputMappingArgsForCall(i int) algorithm.InputMapping {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return fake.saveIndependentInputMappingArgsForCall[i].inputMapping
}

func (fake *FakeJobCombination) SaveIndependentInputMappingReturns(result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	fake.saveIndependentInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) SaveIndependentInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	if fake.saveIndependentInputMappingReturnsOnCall == nil {
		fake.saveIndependentInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveIndependentInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) DeleteNextInputMapping() error {
	fake.deleteNextInputMappingMutex.Lock()
	ret, specificReturn := fake.deleteNextInputMappingReturnsOnCall[len(fake.deleteNextInputMappingArgsForCall)]
	fake.deleteNextInputMappingArgsForCall = append(fake.deleteNextInputMappingArgsForCall, struct{}{})
	fake.recordInvocation("DeleteNextInputMapping", []interface{}{})
	fake.deleteNextInputMappingMutex.Unlock()
	if fake.DeleteNextInputMappingStub != nil {
		return fake.DeleteNextInputMappingStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteNextInputMappingReturns.result1
}

func (fake *FakeJobCombination) DeleteNextInputMappingCallCount() int {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return len(fake.deleteNextInputMappingArgsForCall)
}

func (fake *FakeJobCombination) DeleteNextInputMappingReturns(result1 error) {
	fake.DeleteNextInputMappingStub = nil
	fake.deleteNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) DeleteNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.DeleteNextInputMappingStub = nil
	if fake.deleteNextInputMappingReturnsOnCall == nil {
		fake.deleteNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJobCombination) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.jobIDMutex.RLock()
	defer fake.jobIDMutex.RUnlock()
	fake.combinationMutex.RLock()
	defer fake.combinationMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.createBuildMutex.RLock()
	defer fake.createBuildMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeJobCombination) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.JobCombination = new(FakeJobCombination)
