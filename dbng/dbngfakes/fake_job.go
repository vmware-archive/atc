// This file was generated by counterfeiter
package dbngfakes

import (
	"sync"

	"github.com/concourse/atc"
	"github.com/concourse/atc/dbng"
)

type FakeJob struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct{}
	pausedReturns     struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	FirstLoggedBuildIDStub        func() int
	firstLoggedBuildIDMutex       sync.RWMutex
	firstLoggedBuildIDArgsForCall []struct{}
	firstLoggedBuildIDReturns     struct {
		result1 int
	}
	firstLoggedBuildIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineIDStub        func() int
	pipelineIDMutex       sync.RWMutex
	pipelineIDArgsForCall []struct{}
	pipelineIDReturns     struct {
		result1 int
	}
	pipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	PipelineNameStub        func() string
	pipelineNameMutex       sync.RWMutex
	pipelineNameArgsForCall []struct{}
	pipelineNameReturns     struct {
		result1 string
	}
	pipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct{}
	teamNameReturns     struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	ConfigStub        func() atc.JobConfig
	configMutex       sync.RWMutex
	configArgsForCall []struct{}
	configReturns     struct {
		result1 atc.JobConfig
	}
	configReturnsOnCall map[int]struct {
		result1 atc.JobConfig
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct{}
	unpauseReturns     struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	BuildsStub        func(page dbng.Page) ([]dbng.Build, dbng.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		page dbng.Page
	}
	buildsReturns struct {
		result1 []dbng.Build
		result2 dbng.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []dbng.Build
		result2 dbng.Pagination
		result3 error
	}
	BuildStub        func(name string) (dbng.Build, bool, error)
	buildMutex       sync.RWMutex
	buildArgsForCall []struct {
		name string
	}
	buildReturns struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}
	buildReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}
	FinishedAndNextBuildStub        func() (dbng.Build, dbng.Build, error)
	finishedAndNextBuildMutex       sync.RWMutex
	finishedAndNextBuildArgsForCall []struct{}
	finishedAndNextBuildReturns     struct {
		result1 dbng.Build
		result2 dbng.Build
		result3 error
	}
	finishedAndNextBuildReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 dbng.Build
		result3 error
	}
	UpdateFirstLoggedBuildIDStub        func(newFirstLoggedBuildID int) error
	updateFirstLoggedBuildIDMutex       sync.RWMutex
	updateFirstLoggedBuildIDArgsForCall []struct {
		newFirstLoggedBuildID int
	}
	updateFirstLoggedBuildIDReturns struct {
		result1 error
	}
	updateFirstLoggedBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	SetMaxInFlightReachedStub        func(bool) error
	setMaxInFlightReachedMutex       sync.RWMutex
	setMaxInFlightReachedArgsForCall []struct {
		arg1 bool
	}
	setMaxInFlightReachedReturns struct {
		result1 error
	}
	setMaxInFlightReachedReturnsOnCall map[int]struct {
		result1 error
	}
	GetRunningBuildsBySerialGroupStub        func(serialGroups []string) ([]dbng.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []dbng.Build
		result2 error
	}
	getRunningBuildsBySerialGroupReturnsOnCall map[int]struct {
		result1 []dbng.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(serialGroups []string) (dbng.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}
	getNextPendingBuildBySerialGroupReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeJob) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeJob) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeJob) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeJob) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeJob) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct{}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pausedReturns.result1
}

func (fake *FakeJob) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakeJob) PausedReturns(result1 bool) {
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) PausedReturnsOnCall(i int, result1 bool) {
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeJob) FirstLoggedBuildID() int {
	fake.firstLoggedBuildIDMutex.Lock()
	ret, specificReturn := fake.firstLoggedBuildIDReturnsOnCall[len(fake.firstLoggedBuildIDArgsForCall)]
	fake.firstLoggedBuildIDArgsForCall = append(fake.firstLoggedBuildIDArgsForCall, struct{}{})
	fake.recordInvocation("FirstLoggedBuildID", []interface{}{})
	fake.firstLoggedBuildIDMutex.Unlock()
	if fake.FirstLoggedBuildIDStub != nil {
		return fake.FirstLoggedBuildIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.firstLoggedBuildIDReturns.result1
}

func (fake *FakeJob) FirstLoggedBuildIDCallCount() int {
	fake.firstLoggedBuildIDMutex.RLock()
	defer fake.firstLoggedBuildIDMutex.RUnlock()
	return len(fake.firstLoggedBuildIDArgsForCall)
}

func (fake *FakeJob) FirstLoggedBuildIDReturns(result1 int) {
	fake.FirstLoggedBuildIDStub = nil
	fake.firstLoggedBuildIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) FirstLoggedBuildIDReturnsOnCall(i int, result1 int) {
	fake.FirstLoggedBuildIDStub = nil
	if fake.firstLoggedBuildIDReturnsOnCall == nil {
		fake.firstLoggedBuildIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.firstLoggedBuildIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) PipelineID() int {
	fake.pipelineIDMutex.Lock()
	ret, specificReturn := fake.pipelineIDReturnsOnCall[len(fake.pipelineIDArgsForCall)]
	fake.pipelineIDArgsForCall = append(fake.pipelineIDArgsForCall, struct{}{})
	fake.recordInvocation("PipelineID", []interface{}{})
	fake.pipelineIDMutex.Unlock()
	if fake.PipelineIDStub != nil {
		return fake.PipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipelineIDReturns.result1
}

func (fake *FakeJob) PipelineIDCallCount() int {
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	return len(fake.pipelineIDArgsForCall)
}

func (fake *FakeJob) PipelineIDReturns(result1 int) {
	fake.PipelineIDStub = nil
	fake.pipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) PipelineIDReturnsOnCall(i int, result1 int) {
	fake.PipelineIDStub = nil
	if fake.pipelineIDReturnsOnCall == nil {
		fake.pipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.pipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) PipelineName() string {
	fake.pipelineNameMutex.Lock()
	ret, specificReturn := fake.pipelineNameReturnsOnCall[len(fake.pipelineNameArgsForCall)]
	fake.pipelineNameArgsForCall = append(fake.pipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("PipelineName", []interface{}{})
	fake.pipelineNameMutex.Unlock()
	if fake.PipelineNameStub != nil {
		return fake.PipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipelineNameReturns.result1
}

func (fake *FakeJob) PipelineNameCallCount() int {
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	return len(fake.pipelineNameArgsForCall)
}

func (fake *FakeJob) PipelineNameReturns(result1 string) {
	fake.PipelineNameStub = nil
	fake.pipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) PipelineNameReturnsOnCall(i int, result1 string) {
	fake.PipelineNameStub = nil
	if fake.pipelineNameReturnsOnCall == nil {
		fake.pipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakeJob) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeJob) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeJob) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct{}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamNameReturns.result1
}

func (fake *FakeJob) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeJob) TeamNameReturns(result1 string) {
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) TeamNameReturnsOnCall(i int, result1 string) {
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeJob) Config() atc.JobConfig {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct{}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configReturns.result1
}

func (fake *FakeJob) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeJob) ConfigReturns(result1 atc.JobConfig) {
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.JobConfig
	}{result1}
}

func (fake *FakeJob) ConfigReturnsOnCall(i int, result1 atc.JobConfig) {
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.JobConfig
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.JobConfig
	}{result1}
}

func (fake *FakeJob) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadReturns.result1, fake.reloadReturns.result2
}

func (fake *FakeJob) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeJob) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakeJob) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakeJob) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct{}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unpauseReturns.result1
}

func (fake *FakeJob) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakeJob) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UnpauseReturnsOnCall(i int, result1 error) {
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) Builds(page dbng.Page) ([]dbng.Build, dbng.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		page dbng.Page
	}{page})
	fake.recordInvocation("Builds", []interface{}{page})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildsReturns.result1, fake.buildsReturns.result2, fake.buildsReturns.result3
}

func (fake *FakeJob) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakeJob) BuildsArgsForCall(i int) dbng.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return fake.buildsArgsForCall[i].page
}

func (fake *FakeJob) BuildsReturns(result1 []dbng.Build, result2 dbng.Pagination, result3 error) {
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []dbng.Build
		result2 dbng.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildsReturnsOnCall(i int, result1 []dbng.Build, result2 dbng.Pagination, result3 error) {
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []dbng.Build
			result2 dbng.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []dbng.Build
		result2 dbng.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) Build(name string) (dbng.Build, bool, error) {
	fake.buildMutex.Lock()
	ret, specificReturn := fake.buildReturnsOnCall[len(fake.buildArgsForCall)]
	fake.buildArgsForCall = append(fake.buildArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Build", []interface{}{name})
	fake.buildMutex.Unlock()
	if fake.BuildStub != nil {
		return fake.BuildStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.buildReturns.result1, fake.buildReturns.result2, fake.buildReturns.result3
}

func (fake *FakeJob) BuildCallCount() int {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return len(fake.buildArgsForCall)
}

func (fake *FakeJob) BuildArgsForCall(i int) string {
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	return fake.buildArgsForCall[i].name
}

func (fake *FakeJob) BuildReturns(result1 dbng.Build, result2 bool, result3 error) {
	fake.BuildStub = nil
	fake.buildReturns = struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) BuildReturnsOnCall(i int, result1 dbng.Build, result2 bool, result3 error) {
	fake.BuildStub = nil
	if fake.buildReturnsOnCall == nil {
		fake.buildReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 bool
			result3 error
		})
	}
	fake.buildReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) FinishedAndNextBuild() (dbng.Build, dbng.Build, error) {
	fake.finishedAndNextBuildMutex.Lock()
	ret, specificReturn := fake.finishedAndNextBuildReturnsOnCall[len(fake.finishedAndNextBuildArgsForCall)]
	fake.finishedAndNextBuildArgsForCall = append(fake.finishedAndNextBuildArgsForCall, struct{}{})
	fake.recordInvocation("FinishedAndNextBuild", []interface{}{})
	fake.finishedAndNextBuildMutex.Unlock()
	if fake.FinishedAndNextBuildStub != nil {
		return fake.FinishedAndNextBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.finishedAndNextBuildReturns.result1, fake.finishedAndNextBuildReturns.result2, fake.finishedAndNextBuildReturns.result3
}

func (fake *FakeJob) FinishedAndNextBuildCallCount() int {
	fake.finishedAndNextBuildMutex.RLock()
	defer fake.finishedAndNextBuildMutex.RUnlock()
	return len(fake.finishedAndNextBuildArgsForCall)
}

func (fake *FakeJob) FinishedAndNextBuildReturns(result1 dbng.Build, result2 dbng.Build, result3 error) {
	fake.FinishedAndNextBuildStub = nil
	fake.finishedAndNextBuildReturns = struct {
		result1 dbng.Build
		result2 dbng.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) FinishedAndNextBuildReturnsOnCall(i int, result1 dbng.Build, result2 dbng.Build, result3 error) {
	fake.FinishedAndNextBuildStub = nil
	if fake.finishedAndNextBuildReturnsOnCall == nil {
		fake.finishedAndNextBuildReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 dbng.Build
			result3 error
		})
	}
	fake.finishedAndNextBuildReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 dbng.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) UpdateFirstLoggedBuildID(newFirstLoggedBuildID int) error {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	ret, specificReturn := fake.updateFirstLoggedBuildIDReturnsOnCall[len(fake.updateFirstLoggedBuildIDArgsForCall)]
	fake.updateFirstLoggedBuildIDArgsForCall = append(fake.updateFirstLoggedBuildIDArgsForCall, struct {
		newFirstLoggedBuildID int
	}{newFirstLoggedBuildID})
	fake.recordInvocation("UpdateFirstLoggedBuildID", []interface{}{newFirstLoggedBuildID})
	fake.updateFirstLoggedBuildIDMutex.Unlock()
	if fake.UpdateFirstLoggedBuildIDStub != nil {
		return fake.UpdateFirstLoggedBuildIDStub(newFirstLoggedBuildID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateFirstLoggedBuildIDReturns.result1
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDCallCount() int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return len(fake.updateFirstLoggedBuildIDArgsForCall)
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDArgsForCall(i int) int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return fake.updateFirstLoggedBuildIDArgsForCall[i].newFirstLoggedBuildID
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDReturns(result1 error) {
	fake.UpdateFirstLoggedBuildIDStub = nil
	fake.updateFirstLoggedBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) UpdateFirstLoggedBuildIDReturnsOnCall(i int, result1 error) {
	fake.UpdateFirstLoggedBuildIDStub = nil
	if fake.updateFirstLoggedBuildIDReturnsOnCall == nil {
		fake.updateFirstLoggedBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateFirstLoggedBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) SetMaxInFlightReached(arg1 bool) error {
	fake.setMaxInFlightReachedMutex.Lock()
	ret, specificReturn := fake.setMaxInFlightReachedReturnsOnCall[len(fake.setMaxInFlightReachedArgsForCall)]
	fake.setMaxInFlightReachedArgsForCall = append(fake.setMaxInFlightReachedArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SetMaxInFlightReached", []interface{}{arg1})
	fake.setMaxInFlightReachedMutex.Unlock()
	if fake.SetMaxInFlightReachedStub != nil {
		return fake.SetMaxInFlightReachedStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMaxInFlightReachedReturns.result1
}

func (fake *FakeJob) SetMaxInFlightReachedCallCount() int {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return len(fake.setMaxInFlightReachedArgsForCall)
}

func (fake *FakeJob) SetMaxInFlightReachedArgsForCall(i int) bool {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.setMaxInFlightReachedArgsForCall[i].arg1
}

func (fake *FakeJob) SetMaxInFlightReachedReturns(result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	fake.setMaxInFlightReachedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) SetMaxInFlightReachedReturnsOnCall(i int, result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	if fake.setMaxInFlightReachedReturnsOnCall == nil {
		fake.setMaxInFlightReachedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMaxInFlightReachedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeJob) GetRunningBuildsBySerialGroup(serialGroups []string) ([]dbng.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	ret, specificReturn := fake.getRunningBuildsBySerialGroupReturnsOnCall[len(fake.getRunningBuildsBySerialGroupArgsForCall)]
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		serialGroups []string
	}{serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(serialGroups)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
}

func (fake *FakeJob) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakeJob) GetRunningBuildsBySerialGroupArgsForCall(i int) []string {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeJob) GetRunningBuildsBySerialGroupReturns(result1 []dbng.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) GetRunningBuildsBySerialGroupReturnsOnCall(i int, result1 []dbng.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	if fake.getRunningBuildsBySerialGroupReturnsOnCall == nil {
		fake.getRunningBuildsBySerialGroupReturnsOnCall = make(map[int]struct {
			result1 []dbng.Build
			result2 error
		})
	}
	fake.getRunningBuildsBySerialGroupReturnsOnCall[i] = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeJob) GetNextPendingBuildBySerialGroup(serialGroups []string) (dbng.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	ret, specificReturn := fake.getNextPendingBuildBySerialGroupReturnsOnCall[len(fake.getNextPendingBuildBySerialGroupArgsForCall)]
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		serialGroups []string
	}{serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(serialGroups)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
}

func (fake *FakeJob) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakeJob) GetNextPendingBuildBySerialGroupArgsForCall(i int) []string {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakeJob) GetNextPendingBuildBySerialGroupReturns(result1 dbng.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) GetNextPendingBuildBySerialGroupReturnsOnCall(i int, result1 dbng.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	if fake.getNextPendingBuildBySerialGroupReturnsOnCall == nil {
		fake.getNextPendingBuildBySerialGroupReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 bool
			result3 error
		})
	}
	fake.getNextPendingBuildBySerialGroupReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeJob) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.firstLoggedBuildIDMutex.RLock()
	defer fake.firstLoggedBuildIDMutex.RUnlock()
	fake.pipelineIDMutex.RLock()
	defer fake.pipelineIDMutex.RUnlock()
	fake.pipelineNameMutex.RLock()
	defer fake.pipelineNameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildMutex.RLock()
	defer fake.buildMutex.RUnlock()
	fake.finishedAndNextBuildMutex.RLock()
	defer fake.finishedAndNextBuildMutex.RUnlock()
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeJob) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbng.Job = new(FakeJob)
