// This file was generated by counterfeiter
package dbngfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/db/lock"
	"github.com/concourse/atc/dbng"
)

type FakePipeline struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct{}
	teamNameReturns     struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	ConfigVersionStub        func() dbng.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct{}
	configVersionReturns     struct {
		result1 dbng.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 dbng.ConfigVersion
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct{}
	publicReturns     struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct{}
	pausedReturns     struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	ScopedNameStub        func(string) string
	scopedNameMutex       sync.RWMutex
	scopedNameArgsForCall []struct {
		arg1 string
	}
	scopedNameReturns struct {
		result1 string
	}
	scopedNameReturnsOnCall map[int]struct {
		result1 string
	}
	ConfigStub        func() (atc.Config, atc.RawConfig, dbng.ConfigVersion, error)
	configMutex       sync.RWMutex
	configArgsForCall []struct{}
	configReturns     struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 dbng.ConfigVersion
		result4 error
	}
	configReturnsOnCall map[int]struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 dbng.ConfigVersion
		result4 error
	}
	CheckPausedStub        func() (bool, error)
	checkPausedMutex       sync.RWMutex
	checkPausedArgsForCall []struct{}
	checkPausedReturns     struct {
		result1 bool
		result2 error
	}
	checkPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SaveJobStub        func(job atc.JobConfig) error
	saveJobMutex       sync.RWMutex
	saveJobArgsForCall []struct {
		job atc.JobConfig
	}
	saveJobReturns struct {
		result1 error
	}
	saveJobReturnsOnCall map[int]struct {
		result1 error
	}
	SetMaxInFlightReachedStub        func(string, bool) error
	setMaxInFlightReachedMutex       sync.RWMutex
	setMaxInFlightReachedArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	setMaxInFlightReachedReturns struct {
		result1 error
	}
	setMaxInFlightReachedReturnsOnCall map[int]struct {
		result1 error
	}
	SetResourceCheckErrorStub        func(dbng.Resource, error) error
	setResourceCheckErrorMutex       sync.RWMutex
	setResourceCheckErrorArgsForCall []struct {
		arg1 dbng.Resource
		arg2 error
	}
	setResourceCheckErrorReturns struct {
		result1 error
	}
	setResourceCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllPendingBuildsStub        func() (map[string][]dbng.Build, error)
	getAllPendingBuildsMutex       sync.RWMutex
	getAllPendingBuildsArgsForCall []struct{}
	getAllPendingBuildsReturns     struct {
		result1 map[string][]dbng.Build
		result2 error
	}
	getAllPendingBuildsReturnsOnCall map[int]struct {
		result1 map[string][]dbng.Build
		result2 error
	}
	SaveResourceVersionsStub        func(atc.ResourceConfig, []atc.Version) error
	saveResourceVersionsMutex       sync.RWMutex
	saveResourceVersionsArgsForCall []struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}
	saveResourceVersionsReturns struct {
		result1 error
	}
	saveResourceVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	GetResourceVersionsStub        func(resourceName string, page dbng.Page) ([]dbng.SavedVersionedResource, dbng.Pagination, bool, error)
	getResourceVersionsMutex       sync.RWMutex
	getResourceVersionsArgsForCall []struct {
		resourceName string
		page         dbng.Page
	}
	getResourceVersionsReturns struct {
		result1 []dbng.SavedVersionedResource
		result2 dbng.Pagination
		result3 bool
		result4 error
	}
	getResourceVersionsReturnsOnCall map[int]struct {
		result1 []dbng.SavedVersionedResource
		result2 dbng.Pagination
		result3 bool
		result4 error
	}
	GetLatestVersionedResourceStub        func(resourceName string) (dbng.SavedVersionedResource, bool, error)
	getLatestVersionedResourceMutex       sync.RWMutex
	getLatestVersionedResourceArgsForCall []struct {
		resourceName string
	}
	getLatestVersionedResourceReturns struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}
	getLatestVersionedResourceReturnsOnCall map[int]struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}
	GetVersionedResourceByVersionStub        func(atcVersion atc.Version, resourceName string) (dbng.SavedVersionedResource, bool, error)
	getVersionedResourceByVersionMutex       sync.RWMutex
	getVersionedResourceByVersionArgsForCall []struct {
		atcVersion   atc.Version
		resourceName string
	}
	getVersionedResourceByVersionReturns struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}
	getVersionedResourceByVersionReturnsOnCall map[int]struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}
	DisableVersionedResourceStub        func(versionedResourceID int) error
	disableVersionedResourceMutex       sync.RWMutex
	disableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	disableVersionedResourceReturns struct {
		result1 error
	}
	disableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	EnableVersionedResourceStub        func(versionedResourceID int) error
	enableVersionedResourceMutex       sync.RWMutex
	enableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	enableVersionedResourceReturns struct {
		result1 error
	}
	enableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	GetBuildsWithVersionAsInputStub        func(versionedResourceID int) ([]dbng.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []dbng.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []dbng.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(versionedResourceID int) ([]dbng.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []dbng.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []dbng.Build
		result2 error
	}
	SaveIndependentInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveIndependentInputMappingMutex       sync.RWMutex
	saveIndependentInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveIndependentInputMappingReturns struct {
		result1 error
	}
	saveIndependentInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	SaveNextInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	saveNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	GetIndependentBuildInputsStub        func(jobName string) ([]dbng.BuildInput, error)
	getIndependentBuildInputsMutex       sync.RWMutex
	getIndependentBuildInputsArgsForCall []struct {
		jobName string
	}
	getIndependentBuildInputsReturns struct {
		result1 []dbng.BuildInput
		result2 error
	}
	getIndependentBuildInputsReturnsOnCall map[int]struct {
		result1 []dbng.BuildInput
		result2 error
	}
	GetNextBuildInputsStub        func(jobName string) ([]dbng.BuildInput, bool, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct {
		jobName string
	}
	getNextBuildInputsReturns struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}
	getNextBuildInputsReturnsOnCall map[int]struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}
	DeleteNextInputMappingStub        func(jobName string) error
	deleteNextInputMappingMutex       sync.RWMutex
	deleteNextInputMappingArgsForCall []struct {
		jobName string
	}
	deleteNextInputMappingReturns struct {
		result1 error
	}
	deleteNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	EnsurePendingBuildExistsStub        func(jobName string) error
	ensurePendingBuildExistsMutex       sync.RWMutex
	ensurePendingBuildExistsArgsForCall []struct {
		jobName string
	}
	ensurePendingBuildExistsReturns struct {
		result1 error
	}
	ensurePendingBuildExistsReturnsOnCall map[int]struct {
		result1 error
	}
	GetPendingBuildsForJobStub        func(jobName string) ([]dbng.Build, error)
	getPendingBuildsForJobMutex       sync.RWMutex
	getPendingBuildsForJobArgsForCall []struct {
		jobName string
	}
	getPendingBuildsForJobReturns struct {
		result1 []dbng.Build
		result2 error
	}
	getPendingBuildsForJobReturnsOnCall map[int]struct {
		result1 []dbng.Build
		result2 error
	}
	CreateJobBuildStub        func(jobName string) (dbng.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		jobName string
	}
	createJobBuildReturns struct {
		result1 dbng.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 error
	}
	NextBuildInputsStub        func(jobName string) ([]dbng.BuildInput, bool, error)
	nextBuildInputsMutex       sync.RWMutex
	nextBuildInputsArgsForCall []struct {
		jobName string
	}
	nextBuildInputsReturns struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}
	nextBuildInputsReturnsOnCall map[int]struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}
	DeleteBuildEventsByBuildIDsStub        func(buildIDs []int) error
	deleteBuildEventsByBuildIDsMutex       sync.RWMutex
	deleteBuildEventsByBuildIDsArgsForCall []struct {
		buildIDs []int
	}
	deleteBuildEventsByBuildIDsReturns struct {
		result1 error
	}
	deleteBuildEventsByBuildIDsReturnsOnCall map[int]struct {
		result1 error
	}
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceCheckingLockWithIntervalCheckStub        func(logger lager.Logger, resource dbng.Resource, interval time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceCheckingLockWithIntervalCheckArgsForCall []struct {
		logger    lager.Logger
		resource  dbng.Resource
		interval  time.Duration
		immediate bool
	}
	acquireResourceCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	AcquireResourceTypeCheckingLockWithIntervalCheckStub        func(logger lager.Logger, resourceTypeName string, interval time.Duration, immediate bool) (lock.Lock, bool, error)
	acquireResourceTypeCheckingLockWithIntervalCheckMutex       sync.RWMutex
	acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall []struct {
		logger           lager.Logger
		resourceTypeName string
		interval         time.Duration
		immediate        bool
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct{}
	loadVersionsDBReturns     struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	loadVersionsDBReturnsOnCall map[int]struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	ResourceStub        func(name string) (dbng.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		name string
	}
	resourceReturns struct {
		result1 dbng.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 dbng.Resource
		result2 bool
		result3 error
	}
	ResourcesStub        func() (dbng.Resources, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct{}
	resourcesReturns     struct {
		result1 dbng.Resources
		result2 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 dbng.Resources
		result2 error
	}
	ResourceTypesStub        func() (dbng.ResourceTypes, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct{}
	resourceTypesReturns     struct {
		result1 dbng.ResourceTypes
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 dbng.ResourceTypes
		result2 error
	}
	ResourceTypeStub        func(name string) (dbng.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		name string
	}
	resourceTypeReturns struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}
	JobStub        func(name string) (dbng.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		name string
	}
	jobReturns struct {
		result1 dbng.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 dbng.Job
		result2 bool
		result3 error
	}
	JobsStub        func() ([]dbng.Job, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct{}
	jobsReturns     struct {
		result1 []dbng.Job
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 []dbng.Job
		result2 error
	}
	DashboardStub        func() (dbng.Dashboard, atc.GroupConfigs, error)
	dashboardMutex       sync.RWMutex
	dashboardArgsForCall []struct{}
	dashboardReturns     struct {
		result1 dbng.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}
	dashboardReturnsOnCall map[int]struct {
		result1 dbng.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct{}
	exposeReturns     struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct{}
	hideReturns     struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct{}
	unpauseReturns     struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct{}
	destroyReturns     struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	RenameStub        func(string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct{}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamNameReturns.result1
}

func (fake *FakePipeline) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakePipeline) TeamNameReturns(result1 string) {
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamNameReturnsOnCall(i int, result1 string) {
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) ConfigVersion() dbng.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct{}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configVersionReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionReturns(result1 dbng.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 dbng.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 dbng.ConfigVersion) {
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 dbng.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 dbng.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct{}{})
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if fake.PublicStub != nil {
		return fake.PublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.publicReturns.result1
}

func (fake *FakePipeline) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakePipeline) PublicReturns(result1 bool) {
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PublicReturnsOnCall(i int, result1 bool) {
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct{}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pausedReturns.result1
}

func (fake *FakePipeline) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakePipeline) PausedReturns(result1 bool) {
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedReturnsOnCall(i int, result1 bool) {
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) ScopedName(arg1 string) string {
	fake.scopedNameMutex.Lock()
	ret, specificReturn := fake.scopedNameReturnsOnCall[len(fake.scopedNameArgsForCall)]
	fake.scopedNameArgsForCall = append(fake.scopedNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ScopedName", []interface{}{arg1})
	fake.scopedNameMutex.Unlock()
	if fake.ScopedNameStub != nil {
		return fake.ScopedNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.scopedNameReturns.result1
}

func (fake *FakePipeline) ScopedNameCallCount() int {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return len(fake.scopedNameArgsForCall)
}

func (fake *FakePipeline) ScopedNameArgsForCall(i int) string {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return fake.scopedNameArgsForCall[i].arg1
}

func (fake *FakePipeline) ScopedNameReturns(result1 string) {
	fake.ScopedNameStub = nil
	fake.scopedNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) ScopedNameReturnsOnCall(i int, result1 string) {
	fake.ScopedNameStub = nil
	if fake.scopedNameReturnsOnCall == nil {
		fake.scopedNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.scopedNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Config() (atc.Config, atc.RawConfig, dbng.ConfigVersion, error) {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct{}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.configReturns.result1, fake.configReturns.result2, fake.configReturns.result3, fake.configReturns.result4
}

func (fake *FakePipeline) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakePipeline) ConfigReturns(result1 atc.Config, result2 atc.RawConfig, result3 dbng.ConfigVersion, result4 error) {
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 dbng.ConfigVersion
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) ConfigReturnsOnCall(i int, result1 atc.Config, result2 atc.RawConfig, result3 dbng.ConfigVersion, result4 error) {
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.Config
			result2 atc.RawConfig
			result3 dbng.ConfigVersion
			result4 error
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.Config
		result2 atc.RawConfig
		result3 dbng.ConfigVersion
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) CheckPaused() (bool, error) {
	fake.checkPausedMutex.Lock()
	ret, specificReturn := fake.checkPausedReturnsOnCall[len(fake.checkPausedArgsForCall)]
	fake.checkPausedArgsForCall = append(fake.checkPausedArgsForCall, struct{}{})
	fake.recordInvocation("CheckPaused", []interface{}{})
	fake.checkPausedMutex.Unlock()
	if fake.CheckPausedStub != nil {
		return fake.CheckPausedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkPausedReturns.result1, fake.checkPausedReturns.result2
}

func (fake *FakePipeline) CheckPausedCallCount() int {
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	return len(fake.checkPausedArgsForCall)
}

func (fake *FakePipeline) CheckPausedReturns(result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	fake.checkPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckPausedStub = nil
	if fake.checkPausedReturnsOnCall == nil {
		fake.checkPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadReturns.result1, fake.reloadReturns.result2
}

func (fake *FakePipeline) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipeline) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SaveJob(job atc.JobConfig) error {
	fake.saveJobMutex.Lock()
	ret, specificReturn := fake.saveJobReturnsOnCall[len(fake.saveJobArgsForCall)]
	fake.saveJobArgsForCall = append(fake.saveJobArgsForCall, struct {
		job atc.JobConfig
	}{job})
	fake.recordInvocation("SaveJob", []interface{}{job})
	fake.saveJobMutex.Unlock()
	if fake.SaveJobStub != nil {
		return fake.SaveJobStub(job)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveJobReturns.result1
}

func (fake *FakePipeline) SaveJobCallCount() int {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return len(fake.saveJobArgsForCall)
}

func (fake *FakePipeline) SaveJobArgsForCall(i int) atc.JobConfig {
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	return fake.saveJobArgsForCall[i].job
}

func (fake *FakePipeline) SaveJobReturns(result1 error) {
	fake.SaveJobStub = nil
	fake.saveJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveJobReturnsOnCall(i int, result1 error) {
	fake.SaveJobStub = nil
	if fake.saveJobReturnsOnCall == nil {
		fake.saveJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetMaxInFlightReached(arg1 string, arg2 bool) error {
	fake.setMaxInFlightReachedMutex.Lock()
	ret, specificReturn := fake.setMaxInFlightReachedReturnsOnCall[len(fake.setMaxInFlightReachedArgsForCall)]
	fake.setMaxInFlightReachedArgsForCall = append(fake.setMaxInFlightReachedArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("SetMaxInFlightReached", []interface{}{arg1, arg2})
	fake.setMaxInFlightReachedMutex.Unlock()
	if fake.SetMaxInFlightReachedStub != nil {
		return fake.SetMaxInFlightReachedStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMaxInFlightReachedReturns.result1
}

func (fake *FakePipeline) SetMaxInFlightReachedCallCount() int {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return len(fake.setMaxInFlightReachedArgsForCall)
}

func (fake *FakePipeline) SetMaxInFlightReachedArgsForCall(i int) (string, bool) {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.setMaxInFlightReachedArgsForCall[i].arg1, fake.setMaxInFlightReachedArgsForCall[i].arg2
}

func (fake *FakePipeline) SetMaxInFlightReachedReturns(result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	fake.setMaxInFlightReachedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetMaxInFlightReachedReturnsOnCall(i int, result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	if fake.setMaxInFlightReachedReturnsOnCall == nil {
		fake.setMaxInFlightReachedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMaxInFlightReachedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetResourceCheckError(arg1 dbng.Resource, arg2 error) error {
	fake.setResourceCheckErrorMutex.Lock()
	ret, specificReturn := fake.setResourceCheckErrorReturnsOnCall[len(fake.setResourceCheckErrorArgsForCall)]
	fake.setResourceCheckErrorArgsForCall = append(fake.setResourceCheckErrorArgsForCall, struct {
		arg1 dbng.Resource
		arg2 error
	}{arg1, arg2})
	fake.recordInvocation("SetResourceCheckError", []interface{}{arg1, arg2})
	fake.setResourceCheckErrorMutex.Unlock()
	if fake.SetResourceCheckErrorStub != nil {
		return fake.SetResourceCheckErrorStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setResourceCheckErrorReturns.result1
}

func (fake *FakePipeline) SetResourceCheckErrorCallCount() int {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return len(fake.setResourceCheckErrorArgsForCall)
}

func (fake *FakePipeline) SetResourceCheckErrorArgsForCall(i int) (dbng.Resource, error) {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return fake.setResourceCheckErrorArgsForCall[i].arg1, fake.setResourceCheckErrorArgsForCall[i].arg2
}

func (fake *FakePipeline) SetResourceCheckErrorReturns(result1 error) {
	fake.SetResourceCheckErrorStub = nil
	fake.setResourceCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SetResourceCheckErrorReturnsOnCall(i int, result1 error) {
	fake.SetResourceCheckErrorStub = nil
	if fake.setResourceCheckErrorReturnsOnCall == nil {
		fake.setResourceCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setResourceCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetAllPendingBuilds() (map[string][]dbng.Build, error) {
	fake.getAllPendingBuildsMutex.Lock()
	ret, specificReturn := fake.getAllPendingBuildsReturnsOnCall[len(fake.getAllPendingBuildsArgsForCall)]
	fake.getAllPendingBuildsArgsForCall = append(fake.getAllPendingBuildsArgsForCall, struct{}{})
	fake.recordInvocation("GetAllPendingBuilds", []interface{}{})
	fake.getAllPendingBuildsMutex.Unlock()
	if fake.GetAllPendingBuildsStub != nil {
		return fake.GetAllPendingBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAllPendingBuildsReturns.result1, fake.getAllPendingBuildsReturns.result2
}

func (fake *FakePipeline) GetAllPendingBuildsCallCount() int {
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	return len(fake.getAllPendingBuildsArgsForCall)
}

func (fake *FakePipeline) GetAllPendingBuildsReturns(result1 map[string][]dbng.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	fake.getAllPendingBuildsReturns = struct {
		result1 map[string][]dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetAllPendingBuildsReturnsOnCall(i int, result1 map[string][]dbng.Build, result2 error) {
	fake.GetAllPendingBuildsStub = nil
	if fake.getAllPendingBuildsReturnsOnCall == nil {
		fake.getAllPendingBuildsReturnsOnCall = make(map[int]struct {
			result1 map[string][]dbng.Build
			result2 error
		})
	}
	fake.getAllPendingBuildsReturnsOnCall[i] = struct {
		result1 map[string][]dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SaveResourceVersions(arg1 atc.ResourceConfig, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveResourceVersionsMutex.Lock()
	ret, specificReturn := fake.saveResourceVersionsReturnsOnCall[len(fake.saveResourceVersionsArgsForCall)]
	fake.saveResourceVersionsArgsForCall = append(fake.saveResourceVersionsArgsForCall, struct {
		arg1 atc.ResourceConfig
		arg2 []atc.Version
	}{arg1, arg2Copy})
	fake.recordInvocation("SaveResourceVersions", []interface{}{arg1, arg2Copy})
	fake.saveResourceVersionsMutex.Unlock()
	if fake.SaveResourceVersionsStub != nil {
		return fake.SaveResourceVersionsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveResourceVersionsReturns.result1
}

func (fake *FakePipeline) SaveResourceVersionsCallCount() int {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return len(fake.saveResourceVersionsArgsForCall)
}

func (fake *FakePipeline) SaveResourceVersionsArgsForCall(i int) (atc.ResourceConfig, []atc.Version) {
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	return fake.saveResourceVersionsArgsForCall[i].arg1, fake.saveResourceVersionsArgsForCall[i].arg2
}

func (fake *FakePipeline) SaveResourceVersionsReturns(result1 error) {
	fake.SaveResourceVersionsStub = nil
	fake.saveResourceVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveResourceVersionsReturnsOnCall(i int, result1 error) {
	fake.SaveResourceVersionsStub = nil
	if fake.saveResourceVersionsReturnsOnCall == nil {
		fake.saveResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveResourceVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetResourceVersions(resourceName string, page dbng.Page) ([]dbng.SavedVersionedResource, dbng.Pagination, bool, error) {
	fake.getResourceVersionsMutex.Lock()
	ret, specificReturn := fake.getResourceVersionsReturnsOnCall[len(fake.getResourceVersionsArgsForCall)]
	fake.getResourceVersionsArgsForCall = append(fake.getResourceVersionsArgsForCall, struct {
		resourceName string
		page         dbng.Page
	}{resourceName, page})
	fake.recordInvocation("GetResourceVersions", []interface{}{resourceName, page})
	fake.getResourceVersionsMutex.Unlock()
	if fake.GetResourceVersionsStub != nil {
		return fake.GetResourceVersionsStub(resourceName, page)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.getResourceVersionsReturns.result1, fake.getResourceVersionsReturns.result2, fake.getResourceVersionsReturns.result3, fake.getResourceVersionsReturns.result4
}

func (fake *FakePipeline) GetResourceVersionsCallCount() int {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return len(fake.getResourceVersionsArgsForCall)
}

func (fake *FakePipeline) GetResourceVersionsArgsForCall(i int) (string, dbng.Page) {
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	return fake.getResourceVersionsArgsForCall[i].resourceName, fake.getResourceVersionsArgsForCall[i].page
}

func (fake *FakePipeline) GetResourceVersionsReturns(result1 []dbng.SavedVersionedResource, result2 dbng.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	fake.getResourceVersionsReturns = struct {
		result1 []dbng.SavedVersionedResource
		result2 dbng.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetResourceVersionsReturnsOnCall(i int, result1 []dbng.SavedVersionedResource, result2 dbng.Pagination, result3 bool, result4 error) {
	fake.GetResourceVersionsStub = nil
	if fake.getResourceVersionsReturnsOnCall == nil {
		fake.getResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 []dbng.SavedVersionedResource
			result2 dbng.Pagination
			result3 bool
			result4 error
		})
	}
	fake.getResourceVersionsReturnsOnCall[i] = struct {
		result1 []dbng.SavedVersionedResource
		result2 dbng.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakePipeline) GetLatestVersionedResource(resourceName string) (dbng.SavedVersionedResource, bool, error) {
	fake.getLatestVersionedResourceMutex.Lock()
	ret, specificReturn := fake.getLatestVersionedResourceReturnsOnCall[len(fake.getLatestVersionedResourceArgsForCall)]
	fake.getLatestVersionedResourceArgsForCall = append(fake.getLatestVersionedResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetLatestVersionedResource", []interface{}{resourceName})
	fake.getLatestVersionedResourceMutex.Unlock()
	if fake.GetLatestVersionedResourceStub != nil {
		return fake.GetLatestVersionedResourceStub(resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getLatestVersionedResourceReturns.result1, fake.getLatestVersionedResourceReturns.result2, fake.getLatestVersionedResourceReturns.result3
}

func (fake *FakePipeline) GetLatestVersionedResourceCallCount() int {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return len(fake.getLatestVersionedResourceArgsForCall)
}

func (fake *FakePipeline) GetLatestVersionedResourceArgsForCall(i int) string {
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	return fake.getLatestVersionedResourceArgsForCall[i].resourceName
}

func (fake *FakePipeline) GetLatestVersionedResourceReturns(result1 dbng.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	fake.getLatestVersionedResourceReturns = struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetLatestVersionedResourceReturnsOnCall(i int, result1 dbng.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetLatestVersionedResourceStub = nil
	if fake.getLatestVersionedResourceReturnsOnCall == nil {
		fake.getLatestVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 dbng.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getLatestVersionedResourceReturnsOnCall[i] = struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetVersionedResourceByVersion(atcVersion atc.Version, resourceName string) (dbng.SavedVersionedResource, bool, error) {
	fake.getVersionedResourceByVersionMutex.Lock()
	ret, specificReturn := fake.getVersionedResourceByVersionReturnsOnCall[len(fake.getVersionedResourceByVersionArgsForCall)]
	fake.getVersionedResourceByVersionArgsForCall = append(fake.getVersionedResourceByVersionArgsForCall, struct {
		atcVersion   atc.Version
		resourceName string
	}{atcVersion, resourceName})
	fake.recordInvocation("GetVersionedResourceByVersion", []interface{}{atcVersion, resourceName})
	fake.getVersionedResourceByVersionMutex.Unlock()
	if fake.GetVersionedResourceByVersionStub != nil {
		return fake.GetVersionedResourceByVersionStub(atcVersion, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getVersionedResourceByVersionReturns.result1, fake.getVersionedResourceByVersionReturns.result2, fake.getVersionedResourceByVersionReturns.result3
}

func (fake *FakePipeline) GetVersionedResourceByVersionCallCount() int {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return len(fake.getVersionedResourceByVersionArgsForCall)
}

func (fake *FakePipeline) GetVersionedResourceByVersionArgsForCall(i int) (atc.Version, string) {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return fake.getVersionedResourceByVersionArgsForCall[i].atcVersion, fake.getVersionedResourceByVersionArgsForCall[i].resourceName
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturns(result1 dbng.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	fake.getVersionedResourceByVersionReturns = struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetVersionedResourceByVersionReturnsOnCall(i int, result1 dbng.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	if fake.getVersionedResourceByVersionReturnsOnCall == nil {
		fake.getVersionedResourceByVersionReturnsOnCall = make(map[int]struct {
			result1 dbng.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getVersionedResourceByVersionReturnsOnCall[i] = struct {
		result1 dbng.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DisableVersionedResource(versionedResourceID int) error {
	fake.disableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.disableVersionedResourceReturnsOnCall[len(fake.disableVersionedResourceArgsForCall)]
	fake.disableVersionedResourceArgsForCall = append(fake.disableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("DisableVersionedResource", []interface{}{versionedResourceID})
	fake.disableVersionedResourceMutex.Unlock()
	if fake.DisableVersionedResourceStub != nil {
		return fake.DisableVersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.disableVersionedResourceReturns.result1
}

func (fake *FakePipeline) DisableVersionedResourceCallCount() int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return len(fake.disableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) DisableVersionedResourceArgsForCall(i int) int {
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	return fake.disableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) DisableVersionedResourceReturns(result1 error) {
	fake.DisableVersionedResourceStub = nil
	fake.disableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DisableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.DisableVersionedResourceStub = nil
	if fake.disableVersionedResourceReturnsOnCall == nil {
		fake.disableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.disableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResource(versionedResourceID int) error {
	fake.enableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.enableVersionedResourceReturnsOnCall[len(fake.enableVersionedResourceArgsForCall)]
	fake.enableVersionedResourceArgsForCall = append(fake.enableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("EnableVersionedResource", []interface{}{versionedResourceID})
	fake.enableVersionedResourceMutex.Unlock()
	if fake.EnableVersionedResourceStub != nil {
		return fake.EnableVersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableVersionedResourceReturns.result1
}

func (fake *FakePipeline) EnableVersionedResourceCallCount() int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return len(fake.enableVersionedResourceArgsForCall)
}

func (fake *FakePipeline) EnableVersionedResourceArgsForCall(i int) int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return fake.enableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) EnableVersionedResourceReturns(result1 error) {
	fake.EnableVersionedResourceStub = nil
	fake.enableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.EnableVersionedResourceStub = nil
	if fake.enableVersionedResourceReturnsOnCall == nil {
		fake.enableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInput(versionedResourceID int) ([]dbng.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsInputReturns.result1, fake.getBuildsWithVersionAsInputReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return fake.getBuildsWithVersionAsInputArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturns(result1 []dbng.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []dbng.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []dbng.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutput(versionedResourceID int) ([]dbng.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsOutputReturns.result1, fake.getBuildsWithVersionAsOutputReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return fake.getBuildsWithVersionAsOutputArgsForCall[i].versionedResourceID
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturns(result1 []dbng.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []dbng.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []dbng.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) SaveIndependentInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveIndependentInputMappingMutex.Lock()
	ret, specificReturn := fake.saveIndependentInputMappingReturnsOnCall[len(fake.saveIndependentInputMappingArgsForCall)]
	fake.saveIndependentInputMappingArgsForCall = append(fake.saveIndependentInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveIndependentInputMapping", []interface{}{inputMapping, jobName})
	fake.saveIndependentInputMappingMutex.Unlock()
	if fake.SaveIndependentInputMappingStub != nil {
		return fake.SaveIndependentInputMappingStub(inputMapping, jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveIndependentInputMappingReturns.result1
}

func (fake *FakePipeline) SaveIndependentInputMappingCallCount() int {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return len(fake.saveIndependentInputMappingArgsForCall)
}

func (fake *FakePipeline) SaveIndependentInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return fake.saveIndependentInputMappingArgsForCall[i].inputMapping, fake.saveIndependentInputMappingArgsForCall[i].jobName
}

func (fake *FakePipeline) SaveIndependentInputMappingReturns(result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	fake.saveIndependentInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveIndependentInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	if fake.saveIndependentInputMappingReturnsOnCall == nil {
		fake.saveIndependentInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveIndependentInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveNextInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveNextInputMappingMutex.Lock()
	ret, specificReturn := fake.saveNextInputMappingReturnsOnCall[len(fake.saveNextInputMappingArgsForCall)]
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{inputMapping, jobName})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(inputMapping, jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveNextInputMappingReturns.result1
}

func (fake *FakePipeline) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakePipeline) SaveNextInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return fake.saveNextInputMappingArgsForCall[i].inputMapping, fake.saveNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipeline) SaveNextInputMappingReturns(result1 error) {
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) SaveNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveNextInputMappingStub = nil
	if fake.saveNextInputMappingReturnsOnCall == nil {
		fake.saveNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetIndependentBuildInputs(jobName string) ([]dbng.BuildInput, error) {
	fake.getIndependentBuildInputsMutex.Lock()
	ret, specificReturn := fake.getIndependentBuildInputsReturnsOnCall[len(fake.getIndependentBuildInputsArgsForCall)]
	fake.getIndependentBuildInputsArgsForCall = append(fake.getIndependentBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetIndependentBuildInputs", []interface{}{jobName})
	fake.getIndependentBuildInputsMutex.Unlock()
	if fake.GetIndependentBuildInputsStub != nil {
		return fake.GetIndependentBuildInputsStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getIndependentBuildInputsReturns.result1, fake.getIndependentBuildInputsReturns.result2
}

func (fake *FakePipeline) GetIndependentBuildInputsCallCount() int {
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	return len(fake.getIndependentBuildInputsArgsForCall)
}

func (fake *FakePipeline) GetIndependentBuildInputsArgsForCall(i int) string {
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	return fake.getIndependentBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipeline) GetIndependentBuildInputsReturns(result1 []dbng.BuildInput, result2 error) {
	fake.GetIndependentBuildInputsStub = nil
	fake.getIndependentBuildInputsReturns = struct {
		result1 []dbng.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetIndependentBuildInputsReturnsOnCall(i int, result1 []dbng.BuildInput, result2 error) {
	fake.GetIndependentBuildInputsStub = nil
	if fake.getIndependentBuildInputsReturnsOnCall == nil {
		fake.getIndependentBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []dbng.BuildInput
			result2 error
		})
	}
	fake.getIndependentBuildInputsReturnsOnCall[i] = struct {
		result1 []dbng.BuildInput
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetNextBuildInputs(jobName string) ([]dbng.BuildInput, bool, error) {
	fake.getNextBuildInputsMutex.Lock()
	ret, specificReturn := fake.getNextBuildInputsReturnsOnCall[len(fake.getNextBuildInputsArgsForCall)]
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{jobName})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNextBuildInputsReturns.result1, fake.getNextBuildInputsReturns.result2, fake.getNextBuildInputsReturns.result3
}

func (fake *FakePipeline) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakePipeline) GetNextBuildInputsArgsForCall(i int) string {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return fake.getNextBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipeline) GetNextBuildInputsReturns(result1 []dbng.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) GetNextBuildInputsReturnsOnCall(i int, result1 []dbng.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	if fake.getNextBuildInputsReturnsOnCall == nil {
		fake.getNextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []dbng.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.getNextBuildInputsReturnsOnCall[i] = struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DeleteNextInputMapping(jobName string) error {
	fake.deleteNextInputMappingMutex.Lock()
	ret, specificReturn := fake.deleteNextInputMappingReturnsOnCall[len(fake.deleteNextInputMappingArgsForCall)]
	fake.deleteNextInputMappingArgsForCall = append(fake.deleteNextInputMappingArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("DeleteNextInputMapping", []interface{}{jobName})
	fake.deleteNextInputMappingMutex.Unlock()
	if fake.DeleteNextInputMappingStub != nil {
		return fake.DeleteNextInputMappingStub(jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteNextInputMappingReturns.result1
}

func (fake *FakePipeline) DeleteNextInputMappingCallCount() int {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return len(fake.deleteNextInputMappingArgsForCall)
}

func (fake *FakePipeline) DeleteNextInputMappingArgsForCall(i int) string {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return fake.deleteNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipeline) DeleteNextInputMappingReturns(result1 error) {
	fake.DeleteNextInputMappingStub = nil
	fake.deleteNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.DeleteNextInputMappingStub = nil
	if fake.deleteNextInputMappingReturnsOnCall == nil {
		fake.deleteNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnsurePendingBuildExists(jobName string) error {
	fake.ensurePendingBuildExistsMutex.Lock()
	ret, specificReturn := fake.ensurePendingBuildExistsReturnsOnCall[len(fake.ensurePendingBuildExistsArgsForCall)]
	fake.ensurePendingBuildExistsArgsForCall = append(fake.ensurePendingBuildExistsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("EnsurePendingBuildExists", []interface{}{jobName})
	fake.ensurePendingBuildExistsMutex.Unlock()
	if fake.EnsurePendingBuildExistsStub != nil {
		return fake.EnsurePendingBuildExistsStub(jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ensurePendingBuildExistsReturns.result1
}

func (fake *FakePipeline) EnsurePendingBuildExistsCallCount() int {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return len(fake.ensurePendingBuildExistsArgsForCall)
}

func (fake *FakePipeline) EnsurePendingBuildExistsArgsForCall(i int) string {
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	return fake.ensurePendingBuildExistsArgsForCall[i].jobName
}

func (fake *FakePipeline) EnsurePendingBuildExistsReturns(result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	fake.ensurePendingBuildExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) EnsurePendingBuildExistsReturnsOnCall(i int, result1 error) {
	fake.EnsurePendingBuildExistsStub = nil
	if fake.ensurePendingBuildExistsReturnsOnCall == nil {
		fake.ensurePendingBuildExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensurePendingBuildExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetPendingBuildsForJob(jobName string) ([]dbng.Build, error) {
	fake.getPendingBuildsForJobMutex.Lock()
	ret, specificReturn := fake.getPendingBuildsForJobReturnsOnCall[len(fake.getPendingBuildsForJobArgsForCall)]
	fake.getPendingBuildsForJobArgsForCall = append(fake.getPendingBuildsForJobArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetPendingBuildsForJob", []interface{}{jobName})
	fake.getPendingBuildsForJobMutex.Unlock()
	if fake.GetPendingBuildsForJobStub != nil {
		return fake.GetPendingBuildsForJobStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getPendingBuildsForJobReturns.result1, fake.getPendingBuildsForJobReturns.result2
}

func (fake *FakePipeline) GetPendingBuildsForJobCallCount() int {
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	return len(fake.getPendingBuildsForJobArgsForCall)
}

func (fake *FakePipeline) GetPendingBuildsForJobArgsForCall(i int) string {
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	return fake.getPendingBuildsForJobArgsForCall[i].jobName
}

func (fake *FakePipeline) GetPendingBuildsForJobReturns(result1 []dbng.Build, result2 error) {
	fake.GetPendingBuildsForJobStub = nil
	fake.getPendingBuildsForJobReturns = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetPendingBuildsForJobReturnsOnCall(i int, result1 []dbng.Build, result2 error) {
	fake.GetPendingBuildsForJobStub = nil
	if fake.getPendingBuildsForJobReturnsOnCall == nil {
		fake.getPendingBuildsForJobReturnsOnCall = make(map[int]struct {
			result1 []dbng.Build
			result2 error
		})
	}
	fake.getPendingBuildsForJobReturnsOnCall[i] = struct {
		result1 []dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateJobBuild(jobName string) (dbng.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("CreateJobBuild", []interface{}{jobName})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
}

func (fake *FakePipeline) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakePipeline) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].jobName
}

func (fake *FakePipeline) CreateJobBuildReturns(result1 dbng.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateJobBuildReturnsOnCall(i int, result1 dbng.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) NextBuildInputs(jobName string) ([]dbng.BuildInput, bool, error) {
	fake.nextBuildInputsMutex.Lock()
	ret, specificReturn := fake.nextBuildInputsReturnsOnCall[len(fake.nextBuildInputsArgsForCall)]
	fake.nextBuildInputsArgsForCall = append(fake.nextBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("NextBuildInputs", []interface{}{jobName})
	fake.nextBuildInputsMutex.Unlock()
	if fake.NextBuildInputsStub != nil {
		return fake.NextBuildInputsStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.nextBuildInputsReturns.result1, fake.nextBuildInputsReturns.result2, fake.nextBuildInputsReturns.result3
}

func (fake *FakePipeline) NextBuildInputsCallCount() int {
	fake.nextBuildInputsMutex.RLock()
	defer fake.nextBuildInputsMutex.RUnlock()
	return len(fake.nextBuildInputsArgsForCall)
}

func (fake *FakePipeline) NextBuildInputsArgsForCall(i int) string {
	fake.nextBuildInputsMutex.RLock()
	defer fake.nextBuildInputsMutex.RUnlock()
	return fake.nextBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipeline) NextBuildInputsReturns(result1 []dbng.BuildInput, result2 bool, result3 error) {
	fake.NextBuildInputsStub = nil
	fake.nextBuildInputsReturns = struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) NextBuildInputsReturnsOnCall(i int, result1 []dbng.BuildInput, result2 bool, result3 error) {
	fake.NextBuildInputsStub = nil
	if fake.nextBuildInputsReturnsOnCall == nil {
		fake.nextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []dbng.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.nextBuildInputsReturnsOnCall[i] = struct {
		result1 []dbng.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDs(buildIDs []int) error {
	var buildIDsCopy []int
	if buildIDs != nil {
		buildIDsCopy = make([]int, len(buildIDs))
		copy(buildIDsCopy, buildIDs)
	}
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	ret, specificReturn := fake.deleteBuildEventsByBuildIDsReturnsOnCall[len(fake.deleteBuildEventsByBuildIDsArgsForCall)]
	fake.deleteBuildEventsByBuildIDsArgsForCall = append(fake.deleteBuildEventsByBuildIDsArgsForCall, struct {
		buildIDs []int
	}{buildIDsCopy})
	fake.recordInvocation("DeleteBuildEventsByBuildIDs", []interface{}{buildIDsCopy})
	fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	if fake.DeleteBuildEventsByBuildIDsStub != nil {
		return fake.DeleteBuildEventsByBuildIDsStub(buildIDs)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteBuildEventsByBuildIDsReturns.result1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCallCount() int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return len(fake.deleteBuildEventsByBuildIDsArgsForCall)
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsArgsForCall(i int) []int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return fake.deleteBuildEventsByBuildIDsArgsForCall[i].buildIDs
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturns(result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	fake.deleteBuildEventsByBuildIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturnsOnCall(i int, result1 error) {
	fake.DeleteBuildEventsByBuildIDsStub = nil
	if fake.deleteBuildEventsByBuildIDsReturnsOnCall == nil {
		fake.deleteBuildEventsByBuildIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBuildEventsByBuildIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireSchedulingLockReturns.result1, fake.acquireSchedulingLockReturns.result2, fake.acquireSchedulingLockReturns.result3
}

func (fake *FakePipeline) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipeline) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return fake.acquireSchedulingLockArgsForCall[i].arg1, fake.acquireSchedulingLockArgsForCall[i].arg2
}

func (fake *FakePipeline) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheck(logger lager.Logger, resource dbng.Resource, interval time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall, struct {
		logger    lager.Logger
		resource  dbng.Resource
		interval  time.Duration
		immediate bool
	}{logger, resource, interval, immediate})
	fake.recordInvocation("AcquireResourceCheckingLockWithIntervalCheck", []interface{}{logger, resource, interval, immediate})
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceCheckingLockWithIntervalCheckStub(logger, resource, interval, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireResourceCheckingLockWithIntervalCheckReturns.result1, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result2, fake.acquireResourceCheckingLockWithIntervalCheckReturns.result3
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, dbng.Resource, time.Duration, bool) {
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	return fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].logger, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].resource, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].interval, fake.acquireResourceCheckingLockWithIntervalCheckArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheck(logger lager.Logger, resourceTypeName string, interval time.Duration, immediate bool) (lock.Lock, bool, error) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Lock()
	ret, specificReturn := fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)]
	fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall = append(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall, struct {
		logger           lager.Logger
		resourceTypeName string
		interval         time.Duration
		immediate        bool
	}{logger, resourceTypeName, interval, immediate})
	fake.recordInvocation("AcquireResourceTypeCheckingLockWithIntervalCheck", []interface{}{logger, resourceTypeName, interval, immediate})
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.Unlock()
	if fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub != nil {
		return fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub(logger, resourceTypeName, interval, immediate)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result1, fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result2, fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns.result3
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckCallCount() int {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	return len(fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall)
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckArgsForCall(i int) (lager.Logger, string, time.Duration, bool) {
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	return fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].logger, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].resourceTypeName, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].interval, fake.acquireResourceTypeCheckingLockWithIntervalCheckArgsForCall[i].immediate
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireResourceTypeCheckingLockWithIntervalCheckStub = nil
	if fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall == nil {
		fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceTypeCheckingLockWithIntervalCheckReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	ret, specificReturn := fake.loadVersionsDBReturnsOnCall[len(fake.loadVersionsDBArgsForCall)]
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct{}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.loadVersionsDBReturns.result1, fake.loadVersionsDBReturns.result2
}

func (fake *FakePipeline) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakePipeline) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDBReturnsOnCall(i int, result1 *algorithm.VersionsDB, result2 error) {
	fake.LoadVersionsDBStub = nil
	if fake.loadVersionsDBReturnsOnCall == nil {
		fake.loadVersionsDBReturnsOnCall = make(map[int]struct {
			result1 *algorithm.VersionsDB
			result2 error
		})
	}
	fake.loadVersionsDBReturnsOnCall[i] = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Resource(name string) (dbng.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Resource", []interface{}{name})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceReturns.result1, fake.resourceReturns.result2, fake.resourceReturns.result3
}

func (fake *FakePipeline) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakePipeline) ResourceArgsForCall(i int) string {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return fake.resourceArgsForCall[i].name
}

func (fake *FakePipeline) ResourceReturns(result1 dbng.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 dbng.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceReturnsOnCall(i int, result1 dbng.Resource, result2 bool, result3 error) {
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 dbng.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 dbng.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Resources() (dbng.Resources, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct{}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.resourcesReturns.result1, fake.resourcesReturns.result2
}

func (fake *FakePipeline) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakePipeline) ResourcesReturns(result1 dbng.Resources, result2 error) {
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 dbng.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourcesReturnsOnCall(i int, result1 dbng.Resources, result2 error) {
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 dbng.Resources
			result2 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 dbng.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypes() (dbng.ResourceTypes, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct{}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.resourceTypesReturns.result1, fake.resourceTypesReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesReturns(result1 dbng.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 dbng.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 dbng.ResourceTypes, result2 error) {
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 dbng.ResourceTypes
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 dbng.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceType(name string) (dbng.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("ResourceType", []interface{}{name})
	fake.resourceTypeMutex.Unlock()
	if fake.ResourceTypeStub != nil {
		return fake.ResourceTypeStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.resourceTypeReturns.result1, fake.resourceTypeReturns.result2, fake.resourceTypeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return fake.resourceTypeArgsForCall[i].name
}

func (fake *FakePipeline) ResourceTypeReturns(result1 dbng.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 dbng.ResourceType, result2 bool, result3 error) {
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 dbng.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 dbng.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Job(name string) (dbng.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("Job", []interface{}{name})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(name)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.jobReturns.result1, fake.jobReturns.result2, fake.jobReturns.result3
}

func (fake *FakePipeline) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakePipeline) JobArgsForCall(i int) string {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return fake.jobArgsForCall[i].name
}

func (fake *FakePipeline) JobReturns(result1 dbng.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 dbng.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) JobReturnsOnCall(i int, result1 dbng.Job, result2 bool, result3 error) {
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 dbng.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 dbng.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Jobs() ([]dbng.Job, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct{}{})
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if fake.JobsStub != nil {
		return fake.JobsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.jobsReturns.result1, fake.jobsReturns.result2
}

func (fake *FakePipeline) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakePipeline) JobsReturns(result1 []dbng.Job, result2 error) {
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 []dbng.Job
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) JobsReturnsOnCall(i int, result1 []dbng.Job, result2 error) {
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 []dbng.Job
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 []dbng.Job
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Dashboard() (dbng.Dashboard, atc.GroupConfigs, error) {
	fake.dashboardMutex.Lock()
	ret, specificReturn := fake.dashboardReturnsOnCall[len(fake.dashboardArgsForCall)]
	fake.dashboardArgsForCall = append(fake.dashboardArgsForCall, struct{}{})
	fake.recordInvocation("Dashboard", []interface{}{})
	fake.dashboardMutex.Unlock()
	if fake.DashboardStub != nil {
		return fake.DashboardStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.dashboardReturns.result1, fake.dashboardReturns.result2, fake.dashboardReturns.result3
}

func (fake *FakePipeline) DashboardCallCount() int {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return len(fake.dashboardArgsForCall)
}

func (fake *FakePipeline) DashboardReturns(result1 dbng.Dashboard, result2 atc.GroupConfigs, result3 error) {
	fake.DashboardStub = nil
	fake.dashboardReturns = struct {
		result1 dbng.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) DashboardReturnsOnCall(i int, result1 dbng.Dashboard, result2 atc.GroupConfigs, result3 error) {
	fake.DashboardStub = nil
	if fake.dashboardReturnsOnCall == nil {
		fake.dashboardReturnsOnCall = make(map[int]struct {
			result1 dbng.Dashboard
			result2 atc.GroupConfigs
			result3 error
		})
	}
	fake.dashboardReturnsOnCall[i] = struct {
		result1 dbng.Dashboard
		result2 atc.GroupConfigs
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct{}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.exposeReturns.result1
}

func (fake *FakePipeline) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipeline) ExposeReturns(result1 error) {
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ExposeReturnsOnCall(i int, result1 error) {
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct{}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hideReturns.result1
}

func (fake *FakePipeline) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipeline) HideReturns(result1 error) {
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) HideReturnsOnCall(i int, result1 error) {
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakePipeline) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipeline) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct{}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unpauseReturns.result1
}

func (fake *FakePipeline) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipeline) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnpauseReturnsOnCall(i int, result1 error) {
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct{}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Rename(arg1 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Rename", []interface{}{arg1})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.renameReturns.result1
}

func (fake *FakePipeline) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakePipeline) RenameArgsForCall(i int) string {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.renameArgsForCall[i].arg1
}

func (fake *FakePipeline) RenameReturns(result1 error) {
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) RenameReturnsOnCall(i int, result1 error) {
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.saveJobMutex.RLock()
	defer fake.saveJobMutex.RUnlock()
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	fake.saveResourceVersionsMutex.RLock()
	defer fake.saveResourceVersionsMutex.RUnlock()
	fake.getResourceVersionsMutex.RLock()
	defer fake.getResourceVersionsMutex.RUnlock()
	fake.getLatestVersionedResourceMutex.RLock()
	defer fake.getLatestVersionedResourceMutex.RUnlock()
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	fake.disableVersionedResourceMutex.RLock()
	defer fake.disableVersionedResourceMutex.RUnlock()
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.getIndependentBuildInputsMutex.RLock()
	defer fake.getIndependentBuildInputsMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	fake.ensurePendingBuildExistsMutex.RLock()
	defer fake.ensurePendingBuildExistsMutex.RUnlock()
	fake.getPendingBuildsForJobMutex.RLock()
	defer fake.getPendingBuildsForJobMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.nextBuildInputsMutex.RLock()
	defer fake.nextBuildInputsMutex.RUnlock()
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.acquireResourceCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RLock()
	defer fake.acquireResourceTypeCheckingLockWithIntervalCheckMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbng.Pipeline = new(FakePipeline)
